{"meta":{"title":"Yan","subtitle":"Practice makes perfect.","description":"My technology blog.","author":"Liu Yan","url":"http://yoursite.com"},"pages":[{"title":"About me","date":"2017-03-19T07:51:24.000Z","updated":"2017-03-19T14:39:27.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"EducationWork experienceSkills欢迎您捐赠本站，您的支持是我最大的动力！"},{"title":"Categories","date":"2017-03-19T09:05:49.000Z","updated":"2017-03-19T14:39:59.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tagcloud","date":"2017-03-19T09:01:08.000Z","updated":"2017-03-19T14:40:14.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL数据库的两种存储引擎概要","slug":"DB-Storage-Engine","date":"2017-03-22T14:12:42.000Z","updated":"2017-03-22T14:36:28.000Z","comments":true,"path":"2017/03/22/DB-Storage-Engine/","link":"","permalink":"http://yoursite.com/2017/03/22/DB-Storage-Engine/","excerpt":"","text":"MyISAM和InnoDB作为MySQL的两种主要的存储引擎（在MySql5.5以后版本，Mysql默认采用的是InnoDB） 主要区别 MyISAM不支持事务处理（原子性操作）等高级处理，而InnoDB类型支持（InnoDB的AUTOCOMIIT是打开的） MyISAM表不支持外键； 在执行update、insert、delete等操作时MyISAM会锁表，InnoDB只会锁行（InnoDB琐行也不是绝对的，假如执行一个Sql语句时MySql不能确定要扫描的范围，InnoDB也会锁全表，例如：update table set num=1 where name like “%aaa%”） MyISAM类型强调的是性能，执行的速度比InnoDB要快 InnoDB不能保存表的具体行数，当需要获取表的行数时需要扫描整个表来计算 InnoDB不支持全文索引，MyISAM支持（建立倒排索引） 思考因此，当数据库有大量的写入、更新操作而查询操作较少时或者对数据的完整性要求较高的时候选用InnoDB，而当数据库主要以查询为主而相比较而言更新和写入比较少，并且业务方面数据的完整性要求不那么严格就选用MyISAM表。（MyISAM表的查询操作效率和速度都比InnoDB要快）","categories":[{"name":"Database","slug":"Database","permalink":"http://yoursite.com/categories/Database/"}],"tags":[{"name":"database","slug":"database","permalink":"http://yoursite.com/tags/database/"},{"name":"principle","slug":"principle","permalink":"http://yoursite.com/tags/principle/"}]},{"title":"数据库三范式","slug":"Database-Three Paradigm","date":"2017-03-19T08:34:28.000Z","updated":"2017-03-19T16:36:48.000Z","comments":true,"path":"2017/03/19/Database-Three Paradigm/","link":"","permalink":"http://yoursite.com/2017/03/19/Database-Three Paradigm/","excerpt":"","text":"虽然现在大家用单表很多，表间的关联用逻辑代码实现，但是当需要设计一个高可靠低冗余的数据库存储系统时数据库范式相关的知识还是很重要的。 第一范式（1NF）无重复的列所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能同时有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。 在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。在当前的任何关系数据库管理系统（DBMS）中，不可能做出不符合第一范式的数据库，因为这些DBMS不允许你把数据库表的一列再分成二列或多列。因此，你想在现有的DBMS中设计出不符合第一范式的数据库都是不可能的。 举例：学生表Student(stuNo, stuName, age, age, sex)是不符合第一范式的，age属性重复，去除重复列age以后Student(stuNo, stuName, age, sex)是符合第一范式的。 第二范式（2NF）属性完全依赖于主键（消除部分子函数依赖）第二范式是建立在第一范式的基础上，要求数据库的每个实例或行必须可以被唯一区分，这个唯一属性列被称为主键。 第二范式要求实体的属性完全依赖于主关键字，即：不能存在仅依赖主关键字的一部分属性如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是属性完全依赖于主键。（这里说的主关键字可能不只有一个，有些情况下是存在联合主键的，就是主键有多个属性。） 举例：学生表Student(stuNo, stuName, age, age, sex, courseNo, courseName, credit, score)是不符合第二范式的，联合主键(stuNo, courseNo)能够唯一确定score的属性，再看其他信息，比如stuName只需要stuNo就能够唯一确定，courseName只需要courseNo就能够唯一确定，因此这样就存在了部分依赖，不符合第二范式。如果要让学生课程成绩信息满足第二范式，那么久需要将这张表拆分成多张表，一张学生表Studnet(stuNo,stuName,age,sex)，一张课程表Course(courseNo,courseName,credit)，还有最后一张学生课程成绩表StuGrade(stuNo,courseNo,score)。 第三范式（3NF）属性不依赖于其它非主属性（消除传递依赖）第三范式是建立在第二范式的基础上，要求一个数据库表中不包含已在其它表中已包含的非主关键字。 直接举例：Employee(emp_id,emp_name,emp_age,dept_id,dept_name,dept_info)。这张员工信息表的主键是emp_id，因为这个属性能够唯一确定其他所有属性，比如知道员工编号emp_id以后，肯定能够知道员工姓名，所属部门编号，部门名称和部门介绍。所以这里dept_id不是主属性，而是非主属性。但是，我们又可以发现dept_name,dept_info这两个属性也可以由dept_id这个非主属性决定，即dept_name依赖dept_id，而dept_id依赖emp_id，这样就存在了传递依赖。而且我们可以看出传递依赖的一个明显缺点就是数据冗余非常严重。那么如何解决传递依赖问题，其实非常简单，我们只需要将dept_name,dept_info这连个属性删除就可以了，即Employee(emp_id,emp_name,emp_age,dept_id)，然后再创建一个部门表Dept(dept_id,dept_name,dept_info)。（外键的思想） 思考 数据库的连接会带来一部分的性能损失 并不是数据库的范式越高越好 需要在数据冗余与范式之间走出权衡，在实际的数据库开发过程中，往往会允许一部分的数据冗余来减少数据库的连接","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"database","slug":"database","permalink":"http://yoursite.com/tags/database/"},{"name":"standard","slug":"standard","permalink":"http://yoursite.com/tags/standard/"}]},{"title":"设计模式-单例模式","slug":"Design-Pattern-Design Pattern","date":"2017-03-16T16:00:42.000Z","updated":"2017-03-19T17:03:07.000Z","comments":true,"path":"2017/03/17/Design-Pattern-Design Pattern/","link":"","permalink":"http://yoursite.com/2017/03/17/Design-Pattern-Design Pattern/","excerpt":"","text":"单例模式是最简单的一种常用设计模式，单例模式需要确保一个类只有一个实例，这个类称为单例类（1、单例类只有一个实例，2、这个类必须自行创建这个实例，3、这个类必须自行向整个系统提供这个实例），像资源管理器（打印机）、数据库连接池等都是单例模式的实际应用。 基本原则Java实现单例模式一般需要遵循3个原则： 私有化构造方法，保证外部类无法创建类实例 私有的静态的类型引用，保证只有一个变量引用 提供获取实例的方法getInstance() 实现方法Java中单例模式有以下5种写法：恶汉式、懒汉式、双重校验锁、静态内部类、枚举类型的单例模式，下面分别介绍以下它们的Java实现和优缺点。 恶汉式在类加载的时候就创建了实例，简单，不存在线程安全的问题，缺点是：在不需要的对象的时候也白白创建了对象，造成资源浪费。 12345678910class Singleton &#123; //恶汉式 private static final Singleton singleton = new Singleton(); //在类加载的时候就创建了对象 private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return singleton; &#125;&#125; 懒汉式在需要对象的时候才创建对象，缺点：可能造成线程不安全的问题。 12345678910111213class Singleton2 &#123; //懒汉式 private static Singleton2 singleton2 = null; private Singleton2() &#123; &#125; public static Singleton2 getInstance() &#123; //getInstance()方法可能出现线程安全问题 if(singleton2 == null) &#123; singleton2 = new Singleton2(); &#125; return singleton2; &#125;&#125; 双重校验锁双重校验锁方法是在懒汉式写法上的改进，为了解决懒汉式可能出现的线程安全问题，给getInstance()方法加上同步锁，如下： 12345678public static Singleton2 getInstance() &#123; synchronized (Singleton2.class) &#123; // 加锁 if(singleton2 == null) &#123; singleton2 = new Singleton2(); &#125; &#125; return singleton2;&#125; 但是这种方式效率很低下，会有很多的加锁操作，所以出现兼顾效率和线程安全的写法：双重检查锁，在synchronized之前做一次singleton == null判断可以减少很多加锁操作，极大提升执行效率： 1234567891011121314151617class Singleton3 &#123; // 双重校验锁 private static volatile Singleton3 singleton = null; private Singleton3() &#123; &#125; public static Singleton3 getInstance() &#123; if (singleton == null) &#123; // 避免每次都调用加锁 synchronized (Singleton3.class) &#123; if (singleton == null) &#123; singleton = new Singleton3(); &#125; &#125; &#125; return singleton; &#125;&#125; PS.双重校验锁在jdk1.5以后使用volatile关键字（保证只有一个实例）才能正常达到单例效果 静态内部类静态内部类是创建单例模式的一个很好的方法，静态的内部类只会创建一次，所以是线程安全的 12345678910111213class Singleton4 &#123; // 静态的内部类(静态的内部类只会加载一次，所以是线程安全的) private static class B &#123; private static Singleton4 singleton2 = new Singleton4(); &#125; private Singleton4() &#123; &#125; public static Singleton4 getInstance() &#123; return B.singleton2; &#125;&#125; 枚举单例模式的写法编写一个包含单个元素的模具类型，枚举类型中创建的实例是线程安全的，代码极简单，也是现在很推荐的一种单例模式写法 12345678910// 调用方法Singeton5.INSTANCE.f();enum Singleton5 &#123; INSTANCE; public int i = 0; // 实例变量 public void f() &#123; // 实例方法 System.out.println(\"枚举单例模式\"); &#125;&#125; 总结恶汉式线程安全，但是不能延时加载，资源浪费；懒汉式可以延时加载，但是会存在线程安全问题，加上锁之后效率低下；双重校验锁在jdk1.5之后可以达到单例效果；静态内部类延时加载，减小内存开销，无线程安全问题；枚举不仅能够避免多线程问题，还能防止反序列化重新创建新的对象，写法简单，很好~","categories":[{"name":"programming","slug":"programming","permalink":"http://yoursite.com/categories/programming/"}],"tags":[{"name":"standard","slug":"standard","permalink":"http://yoursite.com/tags/standard/"},{"name":"design pattern","slug":"design-pattern","permalink":"http://yoursite.com/tags/design-pattern/"}]},{"title":"Java垃圾回收机制","slug":"Java-GC","date":"2017-03-16T16:00:42.000Z","updated":"2017-03-19T16:43:39.000Z","comments":true,"path":"2017/03/17/Java-GC/","link":"","permalink":"http://yoursite.com/2017/03/17/Java-GC/","excerpt":"","text":"Java垃圾回收机制相对于C++的巨大改进，避免了因为程序员忘记释放内存而造成的内存溢出错误。 背景Java除了8种基本类型，其它都是引用类型。Java运行时的数据存储区有堆(Heap)和栈(Stack)，一般栈中存放非static自动变量、函数参数、表达式临时结果和函数返回值，还有对象类型的(指针)句柄，栈中的实体数据的分配和释放均是由系统自动完成的。一般堆中存放对象数据类型，堆中的实体数据是由程序显示分配的，开发者只需要在用堆分配的时候创建就行了，何时释放如何释放，都由JVM来做，不需要程序代码来显示的释放。 两种回收策略早期实现GC(Garbage Collection)的是引用计数机制，当有新的指向该对象的引用时，计数器加1，引用移除时，计数器减1，当计数器为0时，认为可以进行垃圾回收。但是这种方式当出现循环引用的时候就不行了。 JVM的处理有两种机制： “mark and sweep标记清除”这种机制下，每个对象都有标记信息，用于表示该对象是否可达。当垃圾回收时，Java程序暂停运行。JVM从根(ROOT)出发，找到可达对象，并标记(mark)，随后，JVM需要扫描整个堆，找到剩余对象，并清空这些对象所占据的内存空间。 “copy and sweep复制清除”这种机制下，堆被分为两个区域，对象总存活于两个区域中的一个。当垃圾回收启动时，Java程序暂停运行，JVM从根（ROOT）出发，找到可达对象，将可到达的对象复制到空白区域中并紧密排列，修改由于对象移动所造成的引用地址变化。最后，直接清空对象原先存活的整个区域，使其成为新的空白区域。 PS. 可以看到，”copy and sweep”需要更加复杂的操作，但也让对象可以紧密排列，避免”mark and sweep”中可能出现的空隙。在新建对象时，”copy and sweep”可以提供大块的连续空间。因此，如果对象都比较”长寿”，那么适用于”mark and sweep”。如果对象的”新陈代谢”比较活跃，那么适用于”copy and sweep”。 分代回收JVM中上面两种机制是通过分代回收(generational collection)混合在一起的。每个对象记录有它的世代(generation)信息。所谓的世代，是指该对象所经历的垃圾回收的次数。世代越久远的对象，在内存中存活的时间越久。根据对Java程序的统计观察，世代越久的对象，越不可能被垃圾回收(富人越富，穷人越穷)。因此，当我们在垃圾回收时，要更多关注那些年轻的对象。 GC分代机制 其中的永久世代(permanent generation)中存活的是Class对象。这些对象不会被垃圾回收(在Java8中已经移除了永久代，新加了一个叫元数据区的native内存区)。年轻世代(young generation)和成熟世代(tenured generation)需要进行垃圾回收。年轻世代中的对象世代较近，而成熟世代中的对象世代较久。 年轻世代又进一步分为三个区域：eden(伊甸): 新生对象存活于该区域。新生对象指从上次GC后新建的对象。from(survivor1),to(survivor2)：这两个区域大小相等，相当于copy and sweep中的两个区域。 当新建对象无法放入eden区时，将出发minor collection。JVM采用copy and sweep的策略，将eden区与from区的可到达对象复制到to区。经过一次垃圾回收，eden区和from区清空，to区中则紧密的存放着存活对象。随后，from区成为新的to区， to区成为新的from区。如果进行minor collection的时候，发现to区放不下，则将部分对象放入成熟世代。另一方面，即使to区没有满，JVM依然会移动世代足够久远的对象（15次拷贝后任然存在的对象）到成熟世代。如果成熟世代放满对象，无法移入新的对象，那么将触发major collection。JVM采用mark and sweep的策略，对成熟世代进行垃圾回收。 如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError:Java heap space异常。 JVM对于循环引用的垃圾回收：如果其他所有对象都没有引用这两个对象，即使这两个对象相互引用，也会被GC因为JVM是从一个根对象开始查找引用的，没有任何路径可以被根对象引用的闭环也会被GC的。 补充java内存溢出的原因： 内存中加载的数据量过于庞大，如一次从数据库取出过多数据； 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； 代码中存在死循环或循环产生过多重复的对象实体。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"principle","slug":"principle","permalink":"http://yoursite.com/tags/principle/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"memory","slug":"memory","permalink":"http://yoursite.com/tags/memory/"}]}]}